# 22. Generate Parentheses [Medium]

The [link](https://leetcode.com/problems/generate-parentheses/) of question.

## Description

Given `n` pairs of parentheses, write a function to generate *all combinations of well-formed parentheses*.

Example 1:
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```

Example 2:
```
Input: n = 1
Output: ["()"]
```

Constraints:
```
1 <= n <= 8
```

## 题目分析

感觉这个问题有点排列组合的味道，当前实现思路如下：对于`n`对合法括号，都是在`n-1`对合法括号构成的字符串构造而来，所谓“构造”，便是在字符串“空隙”中插入`()`。例如：已知有`n = 1`时只有`()`合法，则`n = 2`时在`_(_)_`处分别插入`()`，构成`()()`、`(())`、`()()`，去重后得到`()()` `(())`。同理可递推其他`n`个括号的所有构造。

---

题解给出的思路相对较多，一个个进行分析

1. 暴力法：参数`n`得到的字符串长度为`2n`，共有`2^2n`种情况存在，生成出所有可能，然后验证是否合法。长度为`n`的字符串生成过程是基于长度为`n-1`字符串分别追加`(`和`)`的过程，是个持续倍增的过程。
2. 回溯法：这是对暴力法的改进。关注字符串生成过程，过程中持续关注左括号和右括号数量，从而取消无用字符串的生成、也能取消验证步骤。参数为`n`时，结果字符串必然是左右括号各`n`个，从左到右必然持续保持左括号个数大于等于右括号个数、最终两者个数相等，基于这一性质运行。
3. 闭包计数法：参数为`n`即字符串闭包数为`n`，字符串必然是形如`(` + `str1` + `)` + `str2`。其中`str1`字符串闭包数为`a`、`str2`闭包数为`b`，那么`a+b+1=n`。据此构造递归程序